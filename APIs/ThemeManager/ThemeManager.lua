-- ThemeManager: A comprehensive terminal theme manager for ComputerCraft
-- Allows creating, loading, and applying color themes with UI element mapping

local ThemeManager = {
    -- Configuration (can be modified by users)
    THEMES_DIR = "/themes",
    currentTheme = nil,
    themes = {},
    defaultTheme = "DEFAULT",

    -- Default UI element mappings
    defaultUI = {
        background = "black",
        text = "white",
        header = "blue",
        accent = "purple",
        highlight = "lightGray",
        error = "red",
        success = "green",
        warning = "yellow",
        info = "cyan",
        disabled = "gray",
        border = "gray"
    }
}

-- Color mapping between names and color API values
ThemeManager.colorMap = {
    white = colors.white,
    orange = colors.orange,
    magenta = colors.magenta,
    lightBlue = colors.lightBlue,
    yellow = colors.yellow,
    lime = colors.lime,
    pink = colors.pink,
    gray = colors.gray,
    lightGray = colors.lightGray,
    cyan = colors.cyan,
    purple = colors.purple,
    blue = colors.blue,
    brown = colors.brown,
    green = colors.green,
    red = colors.red,
    black = colors.black
}

-- Initialize the theme manager
function ThemeManager:init()
    -- Ensure the themes directory exists
    if not fs.exists(self.THEMES_DIR) then
        fs.makeDir(self.THEMES_DIR)
    end

    -- Load all available themes
    self:loadThemes()

    -- Create default theme if it doesn't exist
    if not self.themes[self.defaultTheme] then
        self:createDefaultTheme()
    end

    -- Apply default theme if no theme is set
    if not self.currentTheme then
        self:applyTheme(self.defaultTheme)
    end

    return self
end

-- Built-in JSON handling (no dependency on DataManager)
function ThemeManager:readJSON(path)
    if not fs.exists(path) then
        return nil
    end

    local file = fs.open(path, "r")
    local content = file.readAll()
    file.close()

    -- Use textutils to parse JSON
    return textutils.unserializeJSON(content)
end

function ThemeManager:writeJSON(path, data)
    local file = fs.open(path, "w")
    local content = textutils.serializeJSON(data, true) -- true for pretty printing
    file.write(content)
    file.close()
    return true
end

-- Convert hex color string to RGB components
function ThemeManager:hexToRGB(hexColor)
    -- Remove # if present
    hexColor = hexColor:gsub("^#", "")

    -- Parse RGB components
    local r = tonumber(hexColor:sub(1, 2), 16) / 255
    local g = tonumber(hexColor:sub(3, 4), 16) / 255
    local b = tonumber(hexColor:sub(5, 6), 16) / 255

    return r, g, b
end

-- Convert RGB components to hex color string
function ThemeManager:rgbToHex(r, g, b)
    -- Convert from 0-1 range to 0-255 range and format as hex
    local rHex = string.format("%02x", math.floor(r * 255))
    local gHex = string.format("%02x", math.floor(g * 255))
    local bHex = string.format("%02x", math.floor(b * 255))

    return "#" .. rHex .. gHex .. bHex
end

-- Get current terminal palette colors as a theme
function ThemeManager:getCurrentPalette()
    local colors = {}

    for colorName, colorValue in pairs(self.colorMap) do
        local r, g, b = term.getPaletteColor(colorValue)
        colors[colorName] = self:rgbToHex(r, g, b)
    end

    return {
        meta = {
            name = self.currentTheme or "Custom Theme",
            author = "Generated by ThemeManager",
            description = "Auto-saved theme based on current terminal colors",
            version = "1.0.0"
        },
        colors = colors
    }
end

-- Recursively scan directories for theme files
function ThemeManager:scanThemeFiles(directory, prefix)
    prefix = prefix or ""
    local files = {}

    local items = fs.list(directory)
    for _, item in ipairs(items) do
        local path = fs.combine(directory, item)

        if fs.isDir(path) then
            -- Recursively scan subdirectories
            local subFiles = self:scanThemeFiles(path, prefix .. item .. "/")
            for subFileName, subFilePath in pairs(subFiles) do
                files[subFileName] = subFilePath
            end
        elseif item:match("%.json$") then
            -- Store the theme with its relative path as name
            local themeName = prefix .. item:match("(.+)%.json$")
            files[themeName] = path
        end
    end

    return files
end

-- Load all available themes from the themes directory
function ThemeManager:loadThemes()
    self.themes = {}

    -- Get all theme files from directories recursively
    local themeFiles = self:scanThemeFiles(self.THEMES_DIR)

    -- Load each theme
    for themeName, filePath in pairs(themeFiles) do
        local theme = self:readJSON(filePath)
        if theme then
            self.themes[themeName] = theme
            print("[ThemeManager] Loaded theme: " .. themeName)
        end
    end

    return self.themes
end

-- Apply a theme to the terminal
function ThemeManager:applyTheme(themeName)
    local theme = self.themes[themeName]

    if not theme then
        print("[ThemeManager] Theme not found: " .. themeName)
        return false
    end

    -- Check if the theme has the new structure
    local colorData = theme.colors or theme

    -- Apply each color to the terminal palette
    for colorName, hexColor in pairs(colorData) do
        if self.colorMap[colorName] then
            local r, g, b = self:hexToRGB(hexColor)
            term.setPaletteColor(self.colorMap[colorName], r, g, b)
        end
    end

    self.currentTheme = themeName
    print("[ThemeManager] Applied theme: " .. themeName)

    return true
end

-- Save the current palette as a theme
function ThemeManager:saveCurrentTheme(themeName)
    -- Check if themeName contains subdirectories
    local subDir = nil
    local fileName = themeName

    -- Parse directory structure from theme name
    if themeName:find("/") then
        subDir = fs.getDir(themeName)
        fileName = fs.getName(themeName)

        -- Create directory if it doesn't exist
        if not fs.exists(fs.combine(self.THEMES_DIR, subDir)) then
            fs.makeDir(fs.combine(self.THEMES_DIR, subDir))
        end
    end

    local palette = self:getCurrentPalette()

    -- Update metadata with correct name
    palette.meta.name = palette.meta.name == "Custom Theme" and themeName or palette.meta.name

    -- Save to themes directory with proper subdirectory structure
    local path = fs.combine(self.THEMES_DIR, themeName) .. ".json"
    self:writeJSON(path, palette)

    -- Add to loaded themes
    self.themes[themeName] = palette

    print("[ThemeManager] Saved theme: " .. themeName)
    return true
end

-- Create the default CC theme
function ThemeManager:createDefaultTheme()
    -- Default ComputerCraft color palette with metadata
    local defaultTheme = {
        meta = {
            name = "Default Theme",
            author = "ComputerCraft Team",
            description = "The default theme for ComputerCraft, providing a classic look and feel.",
            version = "1.0.0"
        },
        colors = {
            white = "#F0F0F0",
            orange = "#F2B233",
            magenta = "#E57FD8",
            lightBlue = "#99B2F2",
            yellow = "#DEDE6C",
            lime = "#7FCC19",
            pink = "#F2B2CC",
            gray = "#4C4C4C",
            lightGray = "#999999",
            cyan = "#4C99B2",
            purple = "#B266E5",
            blue = "#3366CC",
            brown = "#7F664C",
            green = "#57A64E",
            red = "#CC4C4C",
            black = "#111111"
        },
        gui = {
            background = "black",
            text = "white",
            header = "blue",
            accent = "purple",
            highlight = "lightGray",
            error = "red",
            success = "green",
            warning = "yellow",
            info = "cyan",
            disabled = "gray",
            border = "gray"
        }
    }

    -- Save default theme
    local path = fs.combine(self.THEMES_DIR, self.defaultTheme) .. ".json"
    self:writeJSON(path, defaultTheme)

    -- Add to loaded themes
    self.themes[self.defaultTheme] = defaultTheme

    print("[ThemeManager] Created default theme")
    return true
end

-- Get the default color for a UI element
function ThemeManager:getDefaultUIColor(element)
    if not self.defaultUI[element] then
        print("[ThemeManager] Unknown UI element: " .. element .. ", using 'white' as fallback")
        return colors.white
    end

    local colorName = self.defaultUI[element]
    return self.colorMap[colorName] or colors.white
end

-- Get a color for a UI element based on the current theme
function ThemeManager:getUIColor(element)
    if not element then
        print("[ThemeManager] No UI element specified")
        return colors.white
    end

    local theme = self.themes[self.currentTheme]
    if not theme then
        print("[ThemeManager] No theme active, using default UI colors")
        return self:getDefaultUIColor(element)
    end

    -- Check if theme has GUI mappings
    if not theme.gui or not theme.gui[element] then
        return self:getDefaultUIColor(element)
    end

    -- Get mapped color name
    local colorName = theme.gui[element]

    -- Return the color value
    return self.colorMap[colorName] or self:getDefaultUIColor(element)
end

-- Reset to default CC theme
function ThemeManager:resetToDefault()
    return self:applyTheme(self.defaultTheme)
end

-- Get a list of available theme names with descriptions
function ThemeManager:getThemeNames()
    local themes = {}
    for name, theme in pairs(self.themes) do
        themes[name] = {
            name = (theme.meta and theme.meta.name) or name,
            description = theme.meta and theme.meta.description or "No description available",
            author = theme.meta and theme.meta.author or "Unknown"
        }
    end
    return themes
end

-- Get a list of available theme categories (folders)
function ThemeManager:getThemeCategories()
    local categories = {}

    -- Extract unique categories from theme names
    for name, _ in pairs(self.themes) do
        if name:find("/") then
            local category = name:match("^([^/]+)")
            categories[category] = true
        end
    end

    -- Convert to array
    local result = {}
    for category in pairs(categories) do
        table.insert(result, category)
    end

    return result
end

-- Get all themes in a specific category
function ThemeManager:getThemesByCategory(category)
    local result = {}

    for name, theme in pairs(self.themes) do
        if name:match("^" .. category .. "/") then
            result[name] = theme
        end
    end

    return result
end

-- Get the currently active theme name
function ThemeManager:getCurrentTheme()
    return self.currentTheme
end

-- Preview a theme without applying it
function ThemeManager:previewTheme(themeName, callback)
    local theme = self.themes[themeName]

    if not theme then
        print("[ThemeManager] Theme not found: " .. themeName)
        return false
    end

    -- Save current palette
    local originalPalette = self:getCurrentPalette()
    local originalTheme = self.currentTheme

    -- Apply the preview theme
    self:applyTheme(themeName)

    -- Call user callback or show default preview
    if callback then
        callback()
    else
        -- Default preview - wait for key press
        term.setCursorPos(1, 1)
        term.clear()

        -- Get theme metadata for display
        local displayName = theme.meta and theme.meta.name or themeName
        local description = theme.meta and theme.meta.description or "No description"
        local author = theme.meta and theme.meta.author or "Unknown"

        -- Draw header
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.setCursorPos(1, 1)
        print("Previewing theme: " .. displayName)
        print("By: " .. author)
        print(description)
        print("Press any key to exit")
        print("")

        -- Draw a color preview
        local y = 6
        for colorName, colorValue in pairs(self.colorMap) do
            term.setBackgroundColor(colorValue)
            term.setTextColor(colorValue == colors.black and colors.white or colors.black)
            term.setCursorPos(2, y)
            term.write("  " .. colorName .. "  ")
            y = y + 1
        end

        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)

        os.pullEvent("key")
    end

    -- Restore original palette
    for colorName, hexColor in pairs(originalPalette.colors) do
        if self.colorMap[colorName] then
            local r, g, b = self:hexToRGB(hexColor)
            term.setPaletteColor(self.colorMap[colorName], r, g, b)
        end
    end

    self.currentTheme = originalTheme
    return true
end

-- Initialize on require
return ThemeManager:init()
